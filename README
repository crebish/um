Universal Machine
4/9/2025

Andrea Cabochan
Chance Rebish
========================================================

========================================================
Acknowlegdments 
========================================================

Shoutout to Dan and Ben!

========================================================
Departures from Design
========================================================

Initially planned to implement segmented memory as a separate struct containing 
a sequence of words and a boolean flag indicating whether it was mapped or 
unmapped. Later, to improve efficiency, all elements within the struct were 
integrated into the overall data of the Universal Machine. As a result, the
boolean flags became a sequence within the data struct. 

Originally intended the I/O device to be implemented as a separate object or .c 
file. However, it was ultimately incorporated directly into the um_ops.c 
file for simplicity and performance.

========================================================
Architecture
========================================================
um_data:
The architecture of um_data.c defines a struct that contains a hanson data
sequence of memory segments, an array of eight general-purpose32-bit registers, 
and a unmapped sequence that holds all of the unmapped indices. 
The file includes functions to initialize the UM state from a binary file by 
loading it into segment 0, retrieve and modify words in memory, and access or
update register values. The segment sequence and associated data like size, 
capacity, and memory_index enable dynamic memory management and program control 
flow. This module interfaces closely with the UM operations logic defined in
um_ops.c, enabling execution of instructions through low-level memory and 
register manipulation. 

um_ops:
The architecture of um_ops.c uses the functionalities and data manipulation 
defined in um_data.c to complete specific commands/operations using the 
registers. Used as a helper module for um.c as to keep secrecy of the segmented
memory and helps make sure that the instructions that are being called are 
completed correctly.,513 minutes.

um:
um handles calling on the operation functions in um_ops based on the opcodes 
read in through bitpack operations. um.c also calls initialize_data() to 
initialize all of the data that will be used for the um operations. This data 
struct is the passed into the um_ops functions to directly edit the segmented 
memory and registers based on the opcodes and commands reads in from the bitpack 
operations. These instructions and commands are called within a switch statement 
based on the information extracted from each word. 

========================================================
UM unit test
========================================================

- halt: tests halt by running halt
- halt-verbose: tests halt with random instructions after it to make sure it 
                does not continue
- add: tests the add instruction by adding two numbers together
- print-six: tests the add and output instruction by adding number to ASCII six
             and outputting the result
- add_overflow: tests the add instruction when the number would exceed 32 bits
- divide: tests the divide instruction
- multiply: tests the multiply instruction
- multiply-overflow: tests the multiply instruction when the number would exceed
                     32 bits
- input-output: tests if the given input will be output the same
- no-cmov: tests conditional move when it should do nothing
- yes-cmov: tests conditional move when it should change the registers
- load-and-store: tests to see if segment load and segment store replace the 
                correct instruction and cause the program to halt at the 
                correct position
- map: tests the map function to make sure there is no data leaks
- unmap: test the unmap instruction to make sure there is no data leaks
- nand: tests the nand instruction
- load-program: tests the load program instruction after creating a new segment
               and mapping instruction into it
- load-program2: tests the load program instruction to ensure that the 
                 instruction is making a deep copy
- big-segment: tests the program on a large .um file

========================================================
how many hours you have spent analyzing the problem?
========================================================

~7 hours

========================================================
Explains how long it takes your UM to execute 50 million instructions 
and how you know
========================================================

Currently it takes 4:03.75 minutes to run 11,420 instructions to execute
50 million instructions it would take ~17513 minutes

4 / 11,420 = x / 50 million

x = 17513

========================================================
how many hours you have spent preparing your design?
========================================================

~5 hours

========================================================
how many hours you have spent solving the problems after your analysis?
========================================================

~15 hours