Universal Machine
4/9/2025

Andrea Cabochan
Chance Rebish
========================================================

========================================================
Acknowlegdments 
========================================================

Shoutout to Dan and Ben!

========================================================
Departures from Design
========================================================

Changed memory from a sequence to an array to improve speed and allow instant 
access to indices.

Initially planned to implement memory as a separate struct containing a 
sequence of words and a boolean flag indicating whether it was mapped or 
unmapped. Later, to improve efficiency, all elements within the struct were 
integrated into the overall data of the Universal Machine. As a result, the
boolean flag and the sequence were both converted into arrays.

Originally intended the I/O device to be implemented as a separate object or .c 
file. However, it was ultimately incorporated directly into the um_ops.c 
file for simplicity and performance.

========================================================
Architecture
========================================================

um_data:
The architecture of um_data.c defines a data structure that contains a dynamic 
array of memory segments (memory), eight general-purpose32-bit registers 
(registers), and a mapped array to track whether each memory segment is active. 
The file includes functions to initialize the UM state from a binary file by 
loading it into segment 0, retrieve and modify words in memory, and access or 
update register values. The segment array and associated data like size, 
capacity, and memory_index enable dynamic memory management and program control 
flow. This module interfaces closely with the UM operations logic defined in
um_ops.c, enabling execution of instructions through low-level memory and 
register manipulation.

um_ops:
The architecture of um_ops.c uses the functionalities and data manipulation 
defined in um_data.c to complete specific commands/operations using the 
registers. Used as a helper module for um.c as to keep secrecy and helps make 
sure that the instructions that are being called and completed correctly.

um:



========================================================
Explains how long it takes your UM to execute 50 million instructions 
and how you know
========================================================

Current it takes 57 seconds to run 30,000 lines of insutrcutions to run
50 million it would take ~1666 minutes. 

========================================================
UM unit test
========================================================

- halt: tests halt by running halt
- halt-verbose: tests halt with random instructions after it to make sure it 
                does not continue
- add: tests the add instruction by adding two numbers together
- print-six: tests the add and output instruction by adding number to ASCII six
             and outputting the result
- add_overflow: tests the add instruction when the number would exceed 32 bits
- divide: tests the divide instruction
- multiply: tests the multiply instruction
- multiply_overflow: tests the multiply instruction when the number would exceed
                     32 bits
- input_output: tests if the given input will be output the same
- no_cmov: tests conditional move when it should do nothing
- yes_cmov: tests conditional move when it should change the registers
- loadandstore: tests to see if segment load and segment store replace the 
                correct instruction and cause the program to halt at the 
                correct position
- map_test: tests the map function to make sure there is no data leaks
- unmap_test: test the unmap instruction to make sure there is no data leaks
- nand_test: tests the nand instruction
- loadprogram: tests the load program instruction after creating a new segment
               and mapping instruction into it
- realloc_load: tests the program on a large .um file that forces our 
                implementation to realloc a larger segment 0

========================================================
how many hours you have spent analyzing the problem?
========================================================

~7 hours

========================================================
how many hours you have spent preparing your design?
========================================================

~5 hours

========================================================
how many hours you have spent solving the problems after your analysis?
========================================================

~15 hours